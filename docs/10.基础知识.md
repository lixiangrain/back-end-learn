# 环境变量

## .env 文件

.env 文件是用来存储环境变量的文件，通常包含敏感信息或配置信息，不应该提交到版本控制系统中，可以使用 .env.example 文件来提供示例配置。

### 用途

- 存储数据库连接信息（用户名、密码等）
- 存储 API 密钥
- 存储应用程序配置参数
- 区分不同环境的配置（开发、测试、生产环境）

### 使用方法

1. 安装 dotenv 包：

```bash
npm install dotenv
```

> Nodejs 从 20.6 版本开始支持直接通过 process.env 获取环境变量

2. 在项目根目录创建 .env 文件：

```env
DB_HOST=localhost
DB_USER=root
DB_PASSWORD=password
DB_NAME=myapp
PORT=3000
```

3. 在应用程序中加载环境变量：

```javascript
require("dotenv").config();

console.log(process.env.DB_HOST); // 输出: localhost
```

### 注意事项

- .env 文件应该添加到 .gitignore 中，避免提交到代码仓库
- 不同环境应使用不同的 .env 文件，如 .env.development、.env.production
- 环境变量的值默认都是字符串类型，需要时需进行类型转换

# 配置文件

## YAML 和 YML 格式

YAML（YAML Ain't Markup Language）是一种人类可读的数据序列化标准，常用于配置文件。

### YAML 基本语法

- 使用缩进表示层级关系（不使用 Tab，使用空格）
- 大小写敏感
- 使用 # 表示注释

### 示例

```yaml
server:
  port: 3000
  host: localhost

features:
  - authentication
  - logging
  - caching
```

### 在 Node.js 中使用

1. 安装 yaml 包：

```bash
npm install yaml
```

2. 读取和解析 YAML 文件：

```javascript
const fs = require("fs");
const YAML = require("yaml");

const file = fs.readFile("./config.yaml", "utf8");
const config = YAML.parse(file);

console.log(config.server.port); // 输出: 3000
```

# .env 文件与 YAML 配置文件的区别

| 特性         | .env 文件                | YAML 文件                  |
| ------------ | ------------------------ | -------------------------- |
| **用途**     | 存储简单的键值对环境变量 | 存储复杂的结构化配置数据   |
| **格式**     | KEY=VALUE                | 支持嵌套结构、数组、对象等 |
| **数据类型** | 仅字符串                 | 支持多种数据类型           |
| **使用场景** | 敏感信息、环境特定配置   | 复杂应用配置、功能开关     |
| **示例**     | `PORT=3000`              | `server: { port: 3000 }`   |

.env 文件更适合存储简单的键值对配置，特别是敏感信息如密码、密钥等。而 YAML 文件更适合存储复杂的、结构化的配置信息，例如数据库连接池配置、功能开关、应用设置等。

# 用户注册和登录

## 完整流程

### 注册流程

1. 用户填写注册表单（用户名、邮箱、密码等）
2. 前端验证表单数据
3. 发送注册请求到后端 post, /api/user/register {name email pwd rpwd}
4. 后端验证数据合法性 pwd === rpwd > 400 > 数据有问题
5. 检查用户是否已存在 name 是否在数据库中已经存在 > 400 , 换个名字
6. 对密码进行加密（通常使用 bcrypt） hash > bcrypt.hashSync(password, 10) > stage
7. 将用户信息存储到数据库 > 存起来
8. 返回注册成功响应 > res.status(201).json({ message: "注册成功" });

### 登录流程

1. 用户填写登录表单（用户名/邮箱和密码）
2. 前端验证表单数据
3. 发送登录请求到后端: post, /api/user/login {email pwd}
4. 后端验证用户是否存在: email 是否存在 > 404 , 用户名输入错误
5. 验证密码是否正确（使用 bcrypt 比较） > bcrypt.compareSync(req.body.pwd, 数据库.user.pwd) >
6. 生成 JWT token：
   - 使用 jwt.sign(id, name) 方法生成 token，包含用户 ID 和其他必要信息
7. 返回登录成功响应和 token： res.json({ message: "登录成功", token });

### token 的使用

1. 客户端在登录成功后，将 token 存储在本地（如 localStorage ）
2. 在后续请求中，客户端将 token 放在 Authorization 头中发送给服务器，axios 的请求拦截器，header.Authorization = localStroage.get(token)
3. 服务器中间件验证 token 的有效性，

- jwt.parse(req.headers.token) -> id name 是否过期
- 如果过期，则需要重新申请，否则就正常执行
- 把 id 和 name 存储到请求上下文中，req.user = {id, name}

4. 如果验证通过，允许访问受保护的资源；否则返回 401 未授权错误

### 代码示例

```javascript
// 注册示例
app.post("/register", async (req, res) => {
  try {
    const { username, email, password } = req.body;

    // 检查用户是否已存在
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ message: "用户已存在" });
    }

    // 加密密码
    const hashedPassword = await bcrypt.hash(password, 10);

    // 创建新用户
    const user = new User({ username, email, password: hashedPassword });
    await User.save();

    res.status(201).json({ message: "注册成功" });
  } catch (error) {
    res.status(500).json({ message: "服务器错误" });
  }
});

// 登录示例
app.post("/login", async (req, res) => {
  try {
    const { email, password } = req.body;

    // 查找用户
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(400).json({ message: "用户不存在" });
    }

    // 验证密码
    const isPasswordValid = await bcrypt.compare(password, user.password);
    if (!isPasswordValid) {
      return res.status(400).json({ message: "密码错误" });
    }

    // 生成 JWT token
    const token = jwt.sign(
      { userId: user._id, email: user.email },
      process.env.JWT_SECRET,
      { expiresIn: "24h" }
    );

    res.json({
      message: "登录成功",
      token,
      user: { id: user._id, username: user.username, email: user.email },
    });
  } catch (error) {
    res.status(500).json({ message: "服务器错误" });
  }
});
```

## 为什么用户密码要加密存储？

将用户密码以明文形式存储在数据库中是极其危险的。如果数据库被攻击者获取，所有用户的密码都会泄露，这会导致：

1. **用户隐私泄露**：用户可能在多个网站使用相同密码，一处泄露多处受影响
2. **身份冒用**：攻击者可以使用泄露的密码登录用户账户

### Hash 密码是什么？

Hash（哈希）是一种单向函数，它将任意长度的数据转换为固定长度的字符串。对于密码存储，我们使用密码作为输入，生成一个哈希值存储在数据库中。

特点：

- 单向性：从哈希值无法反推出原始密码
- 确定性：相同输入总是产生相同输出
- 雪崩效应：输入微小变化会导致输出巨大变化

### 常见的密码哈希算法

1. **MD5**：已被证明不安全，容易发生碰撞
2. **SHA-256/SHA-512**：比前两者更安全，但仍不够
3. **bcrypt**：专为密码哈希设计，内置盐值，可调节计算复杂度
4. **scrypt**：内存密集型算法，抗 ASIC 攻击

### 什么是彩虹表？

彩虹表是一种预先计算好的哈希值表，用于快速查找哈希值对应的原始密码。攻击者可以使用彩虹表快速破解简单的哈希密码。

防御彩虹表攻击的方法：

1. **加盐（Salt）**：为每个密码添加随机字符串后再哈希
2. **使用慢哈希算法**：如 bcrypt，增加计算时间成本

```javascript
// bcrypt 示例
const bcrypt = require("bcrypt");

// 加密密码（带盐）
const saltRounds = 10;
const plainPassword = "myPassword123";
const hashedPassword = await bcrypt.hash(plainPassword, saltRounds);

// 验证密码
const isMatch = await bcrypt.compare(plainPassword, hashedPassword);
```

# JWT

## 完整流程

### JWT 简介

JWT（JSON Web Token）是一个开放标准（RFC 7519），它定义了一种紧凑且自包含的方式，用于在各方之间安全地传输信息。

### JWT 结构

JWT 由三部分组成，用点（.）分隔：

1. Header（头部）
2. Payload（载荷）
3. Signature（签名）

格式：`xxxxx.yyyyy.zzzzz`

### 工作流程

1. 用户登录成功后，服务器生成 JWT token
2. 服务器将 token 返回给客户端
3. 客户端在后续请求中将 token 放在 Authorization 头中
4. 服务器验证 token 的有效性
5. 如果验证通过，处理请求；否则返回错误

### 代码示例

```javascript
const jwt = require("jsonwebtoken");

// 生成 token
const generateToken = (payload) => {
  return jwt.sign(payload, process.env.JWT_SECRET, {
    expiresIn: "24h",
  });
};

// 验证 token 中间件
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers["authorization"];
  const token = authHeader && authHeader.split(" ")[1]; // Bearer TOKEN

  if (!token) {
    return res.status(401).json({ message: "访问令牌缺失" });
  }

  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
    if (err) {
      return res.status(403).json({ message: "访问令牌无效" });
    }
    req.user = user;
    next();
  });
};

// 使用示例
app.get("/protected", authenticateToken, (req, res) => {
  res.json({ message: "这是受保护的路由", user: req.user });
});
```

### 注意事项

- JWT 是无状态的，服务器不需要存储 token 信息
- 敏感信息不应放在 payload 中，因为 JWT 可以被解码
- 设置合理的过期时间
- 使用安全的密钥签名

# ORM（TypeORM）

## 什么是 ORM 技术？

ORM（Object Relational Mapping，对象关系映射）是一种编程技术，用于在关系型数据库和对象导向编程语言之间进行数据转换。它创建了一个"虚拟对象数据库"，可以在编程语言中直接操作。

### ORM 的核心概念

1. **实体（Entity）**：与数据库表对应的类
2. **属性（Property）**：与表字段对应的类属性
3. **关系（Relationship）**：表之间的关联关系（一对一、一对多、多对多）
4. **查询构建器**：用于构建数据库查询的工具

### 为什么需要 ORM？

#### 1. 提高开发效率

- 避免编写大量重复的 SQL 语句
- 使用面向对象的方式操作数据库
- 自动生成 SQL 语句

#### 2. 提高代码可维护性

- 更好的代码组织结构
- 类型安全（特别是在 TypeScript 中）
- 易于重构和扩展

#### 3. 数据库无关性

- 可以轻松切换不同的数据库系统
- 统一的 API 接口

#### 4. 安全性

- 自动防止 SQL 注入攻击
- 内置数据验证

#### 5. 高级功能

- 迁移系统
- 关系管理
- 缓存机制
- 事务支持

### ORM 与原生 SQL 的对比

| 特性           | 原生 SQL       | ORM                  |
| -------------- | -------------- | -------------------- |
| **性能**       | 更高           | 略低（有抽象层开销） |
| **学习成本**   | 需要熟悉 SQL   | 需要熟悉 ORM API     |
| **开发效率**   | 复杂查询效率高 | 简单操作效率高       |
| **可维护性**   | 较低           | 较高                 |
| **类型安全**   | 无             | 有（TypeScript）     |
| **数据库切换** | 困难           | 容易                 |

### TypeORM 基本使用

#### 实体定义

```typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
} from "typeorm";

@Entity('user')  // create table user
export class User {
  @PrimaryGeneratedColumn() // id primarykey
  id: number;

  @Column({
    type: "varchar",
    length: 50,
    unique: true,
    nullable: false
  })
  username: string;

  @Column()
  email: string;

  @Column()
  password: string;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  @DeleteDateColumn()
  deletedAt: Date;
}
```

#### 数据库连接

```typescript
import { createConnection } from "typeorm";
import { User } from "./entity/User";

createConnection({
  type: "mysql",
  host: process.env.DB_HOST,
  port: parseInt(process.env.DB_PORT),
  username: process.env.DB_USERNAME,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  entities: [User],
  synchronize: true,
  logging: true,
})
  .then((connection) => {
    // 连接成功
  })
  .catch((error) => console.log(error));
```

## 高级特性

1. 关系（一对一、一对多、多对多）
2. 查询构建器
3. 迁移
4. 事务
5. 钩子函数（生命周期回调）
